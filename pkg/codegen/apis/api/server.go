// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package api

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"log/slog"
	"net/http"

	"github.com/gorilla/mux"
	"github.com/jacobbrewer1/puppet-reporter/pkg/logging"
	"github.com/jacobbrewer1/uhttp"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get all reports
	// GetReports (GET /reports)
	GetReports(l *slog.Logger, r *http.Request, params GetReportsParams) (*ReportResponse, error)

	// Get a report by hash
	// GetReport (GET /reports/{hash})
	GetReport(l *slog.Logger, r *http.Request, hash string) (*ReportDetails, error)

	// Upload a report
	// UploadReport (POST /upload)
	UploadReport(l *slog.Logger, r *http.Request, body0 *UploadReportJSONBody) (*ReportDetails, error)
}

const (
	loggingKeyError = "error"
)

type RateLimiterFunc = func(http.ResponseWriter, context.Context) error
type MetricsMiddlewareFunc = http.HandlerFunc
type ErrorHandlerFunc = func(http.ResponseWriter, context.Context, error)

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	authz             ServerInterface
	handler           ServerInterface
	rateLimiter       RateLimiterFunc
	metricsMiddleware MetricsMiddlewareFunc
	errorHandlerFunc  ErrorHandlerFunc
}

// WithAuthorization applies the passed authorization middleware to the server.
func WithAuthorization(authz ServerInterface) ServerOption {
	return func(s *ServerInterfaceWrapper) {
		s.authz = authz
	}
}

// WithRateLimiter applies the rate limiter middleware to routes with x-global-rate-limit.
func WithRateLimiter(rateLimiter RateLimiterFunc) ServerOption {
	return func(s *ServerInterfaceWrapper) {
		s.rateLimiter = rateLimiter
	}
}

// WithErrorHandlerFunc sets the error handler function for the server.
func WithErrorHandlerFunc(errorHandlerFunc ErrorHandlerFunc) ServerOption {
	return func(s *ServerInterfaceWrapper) {
		s.errorHandlerFunc = errorHandlerFunc
	}
}

// WithMetricsMiddleware applies the metrics middleware to the server.
func WithMetricsMiddleware(middleware MetricsMiddlewareFunc) ServerOption {
	return func(s *ServerInterfaceWrapper) {
		s.metricsMiddleware = middleware
	}
}

// ServerOption represents an optional feature applied to the server.
type ServerOption func(s *ServerInterfaceWrapper)

// GetReports operation middleware
func (siw *ServerInterfaceWrapper) GetReports(w http.ResponseWriter, r *http.Request) {
	l := logging.LoggerFromRequest(r)

	ctx := r.Context()
	cw := uhttp.NewResponseWriter(w,
		uhttp.WithDefaultStatusCode(http.StatusOK),
		uhttp.WithDefaultHeader(uhttp.HeaderRequestID, uhttp.RequestIDFromContext(ctx)),
		uhttp.WithDefaultHeader(uhttp.HeaderContentType, uhttp.ContentTypeJSON),
	)

	defer func() {
		if siw.metricsMiddleware != nil {
			siw.metricsMiddleware(cw, r)
		}
	}()

	// Parameter object where we will unmarshal all parameters from the context
	var params GetReportsParams

	// ------------- Optional query parameter "limit" -------------
	if err := runtime.BindQueryParameter(
		"form",
		true,
		false,
		"limit",
		r.URL.Query(),
		&params.Limit,
	); err != nil {
		siw.errorHandlerFunc(cw, ctx, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "last_val" -------------
	if err := runtime.BindQueryParameter(
		"form",
		true,
		false,
		"last_val",
		r.URL.Query(),
		&params.LastVal,
	); err != nil {
		siw.errorHandlerFunc(cw, ctx, &InvalidParamFormatError{ParamName: "last_val", Err: err})
		return
	}

	// ------------- Optional query parameter "last_id" -------------
	if err := runtime.BindQueryParameter(
		"form",
		true,
		false,
		"last_id",
		r.URL.Query(),
		&params.LastId,
	); err != nil {
		siw.errorHandlerFunc(cw, ctx, &InvalidParamFormatError{ParamName: "last_id", Err: err})
		return
	}

	// ------------- Optional query parameter "sort_by" -------------
	if err := runtime.BindQueryParameter(
		"form",
		true,
		false,
		"sort_by",
		r.URL.Query(),
		&params.SortBy,
	); err != nil {
		siw.errorHandlerFunc(cw, ctx, &InvalidParamFormatError{ParamName: "sort_by", Err: err})
		return
	}

	// ------------- Optional query parameter "sort_dir" -------------
	if err := runtime.BindQueryParameter(
		"form",
		true,
		false,
		"sort_dir",
		r.URL.Query(),
		&params.SortDir,
	); err != nil {
		siw.errorHandlerFunc(cw, ctx, &InvalidParamFormatError{ParamName: "sort_dir", Err: err})
		return
	}

	// ------------- Optional query parameter "host" -------------
	if err := runtime.BindQueryParameter(
		"form",
		true,
		false,
		"host",
		r.URL.Query(),
		&params.Host,
	); err != nil {
		siw.errorHandlerFunc(cw, ctx, &InvalidParamFormatError{ParamName: "host", Err: err})
		return
	}

	// ------------- Optional query parameter "environment" -------------
	if err := runtime.BindQueryParameter(
		"form",
		true,
		false,
		"environment",
		r.URL.Query(),
		&params.Environment,
	); err != nil {
		siw.errorHandlerFunc(cw, ctx, &InvalidParamFormatError{ParamName: "environment", Err: err})
		return
	}

	// ------------- Optional query parameter "state" -------------
	if err := runtime.BindQueryParameter(
		"form",
		true,
		false,
		"state",
		r.URL.Query(),
		&params.State,
	); err != nil {
		siw.errorHandlerFunc(cw, ctx, &InvalidParamFormatError{ParamName: "state", Err: err})
		return
	}

	// ------------- Optional query parameter "from" -------------
	if err := runtime.BindQueryParameter(
		"form",
		true,
		false,
		"from",
		r.URL.Query(),
		&params.From,
	); err != nil {
		siw.errorHandlerFunc(cw, ctx, &InvalidParamFormatError{ParamName: "from", Err: err})
		return
	}

	// ------------- Optional query parameter "to" -------------
	if err := runtime.BindQueryParameter(
		"form",
		true,
		false,
		"to",
		r.URL.Query(),
		&params.To,
	); err != nil {
		siw.errorHandlerFunc(cw, ctx, &InvalidParamFormatError{ParamName: "to", Err: err})
		return
	}

	h := siw.handler.GetReports
	if siw.authz != nil {
		h = siw.authz.GetReports
	}

	// Invoke the callback with all the unmarshalled arguments
	resp, err := h(l, r, params)
	if err != nil {
		siw.errorHandlerFunc(cw, ctx, err)
		return
	}

	w.Header().Set(uhttp.HeaderContentType, "application/json; charset=utf-8")
	w.WriteHeader(200)
	err = json.NewEncoder(w).Encode(resp)
	if err != nil {
		siw.errorHandlerFunc(cw, ctx, err)
		return
	}
}

// GetReport operation middleware
func (siw *ServerInterfaceWrapper) GetReport(w http.ResponseWriter, r *http.Request) {
	l := logging.LoggerFromRequest(r)

	ctx := r.Context()
	cw := uhttp.NewResponseWriter(w,
		uhttp.WithDefaultStatusCode(http.StatusOK),
		uhttp.WithDefaultHeader(uhttp.HeaderRequestID, uhttp.RequestIDFromContext(ctx)),
		uhttp.WithDefaultHeader(uhttp.HeaderContentType, uhttp.ContentTypeJSON),
	)

	defer func() {
		if siw.metricsMiddleware != nil {
			siw.metricsMiddleware(cw, r)
		}
	}()

	// ------------- Path parameter "hash" -------------
	var hash string

	if err := runtime.BindStyledParameterWithOptions(
		"simple",
		"hash",
		mux.Vars(r)["hash"],
		&hash,
		runtime.BindStyledParameterOptions{Explode: false, Required: true},
	); err != nil {
		siw.errorHandlerFunc(cw, ctx, &InvalidParamFormatError{ParamName: "hash", Err: err})
		return
	}

	h := siw.handler.GetReport
	if siw.authz != nil {
		h = siw.authz.GetReport
	}

	// Invoke the callback with all the unmarshalled arguments
	resp, err := h(l, r, hash)
	if err != nil {
		siw.errorHandlerFunc(cw, ctx, err)
		return
	}

	w.Header().Set(uhttp.HeaderContentType, "application/json; charset=utf-8")
	w.WriteHeader(200)
	err = json.NewEncoder(w).Encode(resp)
	if err != nil {
		siw.errorHandlerFunc(cw, ctx, err)
		return
	}
}

// UploadReport operation middleware
func (siw *ServerInterfaceWrapper) UploadReport(w http.ResponseWriter, r *http.Request) {
	l := logging.LoggerFromRequest(r)

	ctx := r.Context()
	cw := uhttp.NewResponseWriter(w,
		uhttp.WithDefaultStatusCode(http.StatusOK),
		uhttp.WithDefaultHeader(uhttp.HeaderRequestID, uhttp.RequestIDFromContext(ctx)),
		uhttp.WithDefaultHeader(uhttp.HeaderContentType, uhttp.ContentTypeJSON),
	)

	defer func() {
		if siw.metricsMiddleware != nil {
			siw.metricsMiddleware(cw, r)
		}
	}()

	body := &UploadReportJSONBody{
		File: new(openapi_types.File),
	}

	bdy, err := io.ReadAll(r.Body)
	if err != nil {
		siw.errorHandlerFunc(cw, ctx, &UnmarshalingParamError{ParamName: "body", Err: err})
		return
	}

	body.File.InitFromBytes(bdy, "file")

	h := siw.handler.UploadReport
	if siw.authz != nil {
		h = siw.authz.UploadReport
	}

	// Invoke the callback with all the unmarshalled arguments
	resp, err := h(l, r, body)
	if err != nil {
		siw.errorHandlerFunc(cw, ctx, err)
		return
	}

	w.Header().Set(uhttp.HeaderContentType, "application/json; charset=utf-8")
	w.WriteHeader(201)
	err = json.NewEncoder(w).Encode(resp)
	if err != nil {
		siw.errorHandlerFunc(cw, ctx, err)
		return
	}
}

// handleError handles returning a correctly-formatted error to the API caller.
func handleError(w http.ResponseWriter, ctx context.Context, err error) {
	l := logging.LoggerFromContext(ctx)
	l.Error("Error handling request", slog.String(loggingKeyError, err.Error()))

	e := new(uhttp.HTTPError)
	if errors.As(err, &e) {
		e.RequestID = uhttp.RequestIDFromContext(ctx)
		_ = encodeErrorResponse(w, e)
		return
	}

	code := http.StatusInternalServerError
	if e, ok := err.(uhttp.StatusCoder); ok {
		code = e.StatusCode()
	}

	_ = encodeErrorResponse(w, &uhttp.HTTPError{
		Title:     http.StatusText(code),
		Detail:    "error handling request",
		Status:    code,
		RequestID: uhttp.RequestIDFromContext(ctx),
		Details: []interface{}{
			err.Error(),
		},
	})
}

// encodeErrorResponse encodes input response as an RFC-7807-compliant response to w.
func encodeErrorResponse(w http.ResponseWriter, response any) error {
	w.Header().Set(uhttp.HeaderContentType, "application/problem+json; charset=utf-8")

	if e, ok := response.(uhttp.StatusCoder); ok {
		w.WriteHeader(e.StatusCode())
	}

	return json.NewEncoder(w).Encode(response)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) StatusCode() int {
	return http.StatusBadRequest
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) StatusCode() int {
	return http.StatusBadRequest
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) StatusCode() int {
	return http.StatusBadRequest
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) StatusCode() int {
	return http.StatusBadRequest
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) StatusCode() int {
	return http.StatusBadRequest
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) StatusCode() int {
	return http.StatusBadRequest
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// wrapHandler will wrap the handler with middlewares in the other specified
// making the execution order the inverse of the parameter declaration
func wrapHandler(handler http.HandlerFunc, middlewares ...mux.MiddlewareFunc) http.Handler {
	var wrappedHandler http.Handler = handler
	for _, middleware := range middlewares {
		if middleware == nil {
			continue
		}
		wrappedHandler = middleware(wrappedHandler)
	}
	return wrappedHandler
}

// RegisterUnauthedHandlers registers any api handlers which do not have any authentication on them. Most services will not have any.
func RegisterUnauthedHandlers(router *mux.Router, si ServerInterface, opts ...ServerOption) {
	wrapper := ServerInterfaceWrapper{
		authz:             nil,
		handler:           si,
		rateLimiter:       nil,
		metricsMiddleware: nil,
		errorHandlerFunc:  handleError,
	}

	for _, opt := range opts {
		if opt == nil {
			continue
		}
		opt(&wrapper)
	}

	router.Use(uhttp.AuthHeaderToContextMux())
	router.Use(uhttp.GenerateOrCopyRequestIDMux())

	router.Methods(http.MethodGet).Path("/reports").Handler(wrapHandler(wrapper.GetReports))
	router.Methods(http.MethodGet).Path("/reports/{hash}").Handler(wrapHandler(wrapper.GetReport))
	router.Methods(http.MethodPost).Path("/upload").Handler(wrapHandler(wrapper.UploadReport))
}
